我们知道，在java中，数字会分为整型和浮点型，其中浮点型区分为单精度跟双精度格式。但是在JS中，只有Number型，并不区分整型跟浮点型，数字统一采用IEEE 754标准的64位双精格式进行存储。
#### 1.IEEE 754的双精度
IEE754浮点数由基本构成：符号域(S)、指数域(E)、尾数域(M)，给定数值V，用浮点数表述为`
```
V = (-1)^S×2^*(E-1023)*1.M
```
其中IEEE 754的双精度对这三个区域的定义为： 
1. 符号域S：占1位 （0代表正数，1代表负数）
2. 指数E：也叫阶码（exponent），表示2的幂，它的作用是对浮点数加权。
3. 尾数域(M)：M是二进制小数。

顺便提一下，32位单精度由1位符号位+8位阶码+23位尾数构成。
##### 1.1 为什么会有偏移量1023
11位指数表示范围为[-1024,1023], 需要引入符号位，例如将高位置1表示负数，这样0-1023表示正数，1024-2047表示负数。但这会给机器比较数字大小带来
麻烦（例如机器会认为2000比1023大，但实际上2000表示的是一个负数）。为了简化操作，可以考虑整体偏移1024位，变成[0,2047],要想得到原来的数字，只需要将存储数字减少1024即可。而由于数字0和2047用于非规格化的情况，只能特殊处理（后面会介绍什么是规格化），去除了2个数字，所以用1023作偏移量即可。这种通过偏移，使得所有的数可以不用去考虑其符号的方法叫余码系统。经过以上处理，可以将指数的真实值称为阶码真值，阶码真值与偏移量相加得到阶码，阶码就是实际存储在机器上的数字。
##### 1.2 尾数M实际有多少位
同一浮点数的表示方法有很多种，但规范一般采用科学计数法，二进制只有0和1，那么按照科学计数法，首位只可能是1，对此IEEE省略了默认的1，所以实际上有效尾数是有53位的。这时会出现一个问题， 尾数M省略的1是一定会存在的，以至于无法表示0。不过IEEE 754早就想到了这个问题。
